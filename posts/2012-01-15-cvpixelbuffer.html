<article>CMSampleBuffer なんかから得られる CVPixelBuffer を保存したくなったのでしてみた。やってることは NSData を使って生のデータを保存しているだけ。このときに、再利用時に必要となりそうなパラメータをファイル名に埋め込んでいる。  <pre class="brush: objc"><br />- (BOOL)writeBuffer:(CVPixelBufferRef)imageBuffer<br />{<br />    CVPixelBufferLockBaseAddress(imageBuffer, 0);<br />    NSURL *fileURL = [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDirectory] lastObject];<br />    int bufferSize = CVPixelBufferGetDataSize(imageBuffer);<br />    int width = CVPixelBufferGetWidth(imageBuffer);<br />    int height = CVPixelBufferGetHeight(imageBuffer);<br />    int bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);<br /> <br />    NSString *fileName = [NSString stringWithFormat:@"buffer_%dx%d_%d_%d", width, height, bytesPerRow, bufferSize];<br />    <br />    unsigned char *baseAddress = (unsigned char *)CVPixelBufferGetBaseAddress(imageBuffer);<br />    NSData *data = [NSData dataWithBytes:baseAddress length:bufferSize];<br />    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);<br />    <br />    NSLog(@"PATH: %@", fileURL);<br />    if ([data writeToURL:[fileURL URLByAppendingPathComponent:fileName] atomically:YES]) {<br />        NSLog(@"success");<br />        return YES;<br />    }else{<br />        NSLog(@"fail");<br />        return NO;<br />    }<br />}<br /></pre> 保存した生のデータを UIImage にするのはこんな感じ。決めうちで入れている値はファイル名から取得したもの。パースが必要なら NSScaner なり、ファイル名をもうちょっと工夫して -[NSString componentsSeparatedByString:] なりを使うとよさそう。 <pre class="brush: objc"><br />- (UIImage*)imageWithImageBufferContentsOfURL:(NSURL*)url<br />    NSData *data = [NSData dataWithContentsOfURL:url];<br />    if (!data) {<br />        NSLog(@"error");<br />        return nil;<br />    }<br />    CVPixelBufferRef imageBuffer = (CVPixelBufferRef)[data bytes];<br /><br />    size_t bufferSize = 128808;<br />    size_t bytesPerRow = 2560;<br />    size_t width = 640;<br />    size_t height = 480;<br /><br />    static CGColorSpaceRef colorSpace = NULL; if (colorSpace == NULL) {<br />        colorSpace = CGColorSpaceCreateDeviceRGB(); if (colorSpace == NULL) {<br />            NSLog(@"error");<br />            return nil;<br />        } }<br /><br />    void *baseAddress = imageBuffer;<br />    CGDataProviderRef dataProvider =<br />    CGDataProviderCreateWithData(NULL, baseAddress, bufferSize, NULL);<br />    CGImageRef cgImage =<br />    CGImageCreate(width, height, 8, 32, bytesPerRow,<br />                  colorSpace, kCGImageAlphaNoneSkipFirst |<br />                  kCGBitmapByteOrder32Little,<br />                  dataProvider, NULL, true, kCGRenderingIntentDefault);<br />    CGDataProviderRelease(dataProvider);<br />    UIImage *image = [UIImage imageWithCGImage:cgImage];<br />    CGImageRelease(cgImage);<br /><br />    return image<br />}<br /></pre></article>
