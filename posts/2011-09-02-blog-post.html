<ins datetime='2011-12-25'>あまりに簡素だったので追記</ins><section><h1>まえがき</h1>UIView などの既存のクラスにメソッドを追加するにはカテゴリを使うのが一般的（参考：http://news.mynavi.jp/column/objc/008/index.html）。 あるいは全く異なる機能を持たせたいならオーバーライドする。 では、既存のメソッドの機能を残しつつ、そこに独自の機能を追加したい場合はどうするか。一番スマートなのはサブクラスを作成して対処する方法。じゃあ、「サブクラス」なんか作りたくない、という時はどうするか。Delegate などで対処できないかよく考慮した上で、ダメなら自分で作ったメソッドと置き換えてしまおう。 </section> <section><h1>runtime.h</h1>runtime.h ヘッダーにはmethod_exchangeImplementationsというメソッドを置き換える関数が用意されている。 これとカテゴリによるメソッドの追加を組み合わせればメソッドに独自の機能を追加することができる。 - [UITableView reloadData] を reloadData2 で置き換えてみよう。まずは reloadData2 を用意する。  <pre class="brush: objc"><br />- (void)reloadData2<br />{<br />    [self reloadData2];<br />    SEL selector = @selector(tableViewDidEndReloadingData:);<br />    if( self.delegate && [self.delegate respondsToSelector:selector] ){<br />        [self.delegate performSelector:selector withObject:self];<br />    }<br />}<br />@end</pre> ここで、reloadData2 の中で reloadData2 を呼び出していることに注意。メソッドが置き換わると - [UITableView reloadData] の呼び出しで上記の reloadData2 が呼び出される。この時、- [UITableView reloadData2] で呼び出されるのはオリジナルの reloadData だ。今回は元々の reloadData を呼び出した後に delegate に対して tableViewDidEndReloadingData: メソッドを呼び出すようにしている。  追加するメソッドが用意できたら次はいよいよ置き換えだ。 <pre class="brush: objc">#import &lt;objc/runtime.h&gt;<br />static void UITableViewReplaceReloadDataMethod(void)<br />{<br />    Method original = class_getInstanceMethod([UITableView class], @selector(reloadData));<br />    Method replace = class_getInstanceMethod([UITableView class], @selector(reloadData2));<br />    method_exchangeImplementations(original, replace);<br />}<br /></pre>runtime.h ヘッダーをインポートを忘れないように注意する。コードはいたって簡単だ。これをアプリケーションのどこかで呼び出せば良いのだけど、注意は１度だけ呼び出すということ。なんども呼び出してしまうと、オリジナルの reloadData を呼び出したり、reloadData2 を呼び出したりしてしまう。 -[AppDelegate init] とか -[AppDelegate awakeFromNib] あたりが良いのではないかな。 </section>
